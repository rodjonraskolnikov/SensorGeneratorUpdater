// class definition
------------------------- Head Sensor ---------------------------------
Class Head is

Signals :
receivedFromRight ( alarm : bool ),
update ( offset : int ),
finish ( nowRound : int )

Operations :

Vars :
rightSensor :obj ,
roundAlarmed :int = 0 ,
round :int ,
temperature : int ,
offsetTemperature : int [] ,
threshold : int = 50,
isAlarmed : bool = False,
myupdate : obj

State Top = startRound , update , waiting , fire , safe

Transitions :

   
startRound -> update { - [round > 0 ] /
    round = round - 1;
    if (temperature < threshold) {rightSensor . consecutiveAboveThreshold (0 , round)}
    else {rightSensor . consecutiveAboveThreshold (1 , round)} }

    
startRound -> safe { - [round == 0] / - }

update -> waiting { - / 
    temperature = temperature + offsetTemperature[round] }

waiting -> startRound { receivedFromRight ( alarm ) [ alarm == True && roundAlarmed < 2 ] /
    roundAlarmed = roundAlarmed + 1; temperature = temperature + 10  }
    
waiting -> fire { receivedFromRight ( alarm ) [ alarm == True && roundAlarmed == 2 ] / 
    roundAlarmed = roundAlarmed + 1 }

waiting -> startRound { receivedFromRight ( alarm ) [ alarm == False ] / 
    roundAlarmed = 0 }

waiting -> update { update(offset) /
    offsetTemperature[round] = offset ; myupdate.finish }
 

end Head




------------------------- Intermediate sensor ---------------------------------
Class Intermediate is

Signals :
consecutiveAboveThreshold ( consecutives : int, round : int ),
alarmFromLeft ( alarm : bool ),
receivedFromRight ( alarm : bool ),
update ( offset : int ),
finish ( nowRound : int )

Operations :

Vars :
rightSensor :obj ,
leftSensor :obj ,
temperature : int ,
offsetTemperature : int [] ,
threshold : int = 50 ,
isAlarmed : bool = False ,
nowRound : int ,
myupdate : obj

State Top = standby , update , alarm

Transitions :
standby -> update { consecutiveAboveThreshold ( consecutives, round ) [ temperature < threshold ] / 
    rightSensor . consecutiveAboveThreshold (0 , round ); nowRound = round }

standby -> update
{ consecutiveAboveThreshold ( consecutives , round ) [ consecutives < 2 && temperature >= threshold ] / 
    rightSensor . consecutiveAboveThreshold ( consecutives + 1 , round ); nowRound = round }
  
standby -> alarm { consecutiveAboveThreshold ( consecutives , round ) [ consecutives == 2 && temperature >= threshold ] / 
    isAlarmed = True; leftSensor . receivedFromRight ( isAlarmed ); rightSensor . alarmFromLeft ( isAlarmed ); nowRound = round }
    
standby -> alarm {alarmFromLeft (alarm) /
    isAlarmed = alarm; rightSensor . alarmFromLeft ( isAlarmed )}
standby -> standby { receivedFromRight ( alarm ) [alarm == False] / 
    isAlarmed = alarm; leftSensor . receivedFromRight ( isAlarmed ) }
    
standby -> alarm { receivedFromRight ( alarm ) [alarm == True] / 
    isAlarmed = alarm; leftSensor . receivedFromRight ( isAlarmed ) }
      
alarm -> update { - / temperature = temperature + 10 }

update -> standby { - / temperature = temperature + offsetTemperature[nowRound] }

standby -> update { update(offset) /
    offsetTemperature[nowRound] = offset ; myupdate.finish }

    
end Intermediate




------------------------- Tail Sensor ---------------------------------
Class Tail is

Signals:
consecutiveAboveThreshold ( consecutives : int , round : int ),
alarmFromLeft ( alarm : bool ) ,
update ( offset : int )


Operations :

Vars :
leftSensor :obj ,
temperature : int ,
offsetTemperature : int [] ,
threshold : int = 50 ,
isAlarmed : bool = False ,
nowRound : int ,
myupdate : obj

State Top = standby , update , alarm

Transitions :
standby -> update { consecutiveAboveThreshold ( consecutives , round ) [ consecutives < 3 && temperature < threshold ] / 
    isAlarmed = False; leftSensor . receivedFromRight ( isAlarmed ); nowRound = round }

standby -> update
{ consecutiveAboveThreshold ( consecutives , round  ) [ consecutives < 2  ] / 
    isAlarmed = False; leftSensor . receivedFromRight ( isAlarmed ); nowRound = round }

standby -> alarm { consecutiveAboveThreshold ( consecutives , round ) [ consecutives >= 2 && temperature >= threshold ] / 
    isAlarmed = True; leftSensor . receivedFromRight ( isAlarmed ); nowRound = round }
    
standby -> alarm { alarmFromLeft ( alarm ) / 
    isAlarmed = alarm; }

standby -> update { update(offset) /
    offsetTemperature[nowRound] = offset ; myupdate.finish }

alarm -> update { - / temperature = temperature + 10  }

update -> standby { - / temperature = temperature + offsetTemperature[nowRound] }

end Tail

Class UpdateSensor is
Signals :
finish

Operations :

Vars :
temperature : int [] ,
sensor :obj [] ,
nowRound : int

State Top = standby, update

Transitions:                   
standby -> update { - [nowRound>=0] /
    sensor [nowRound mod sensor.length ] . update( temperature [nowRound mod temperature.length]) }
    
update -> standby { finish / nowRound = nowRound - 1 }
    
end UpdateSensor

--------- Insert here the code generated by the C++ “UMC code generator” ---------

Abstractions{
State : inState ( sensor1 . fire ) -> Fire
State : inState ( sensor1 . safe ) -> Safe
State : sensor2 . isAlarmed == True -> Alarm 

}